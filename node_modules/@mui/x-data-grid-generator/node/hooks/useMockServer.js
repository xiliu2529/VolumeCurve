"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMockServer = exports.BASE_URL = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
var _lruCache = _interopRequireDefault(require("lru-cache"));
var _xDataGridPro = require("@mui/x-data-grid-pro");
var _useDemoData = require("./useDemoData");
var _realDataService = require("../services/real-data-service");
var _treeDataGenerator = require("../services/tree-data-generator");
var _serverUtils = require("./serverUtils");
var _services = require("../services");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const dataCache = new _lruCache.default({
  max: 10,
  ttl: 60 * 5 * 1e3 // 5 minutes
});
const BASE_URL = exports.BASE_URL = 'https://mui.com/x/api/data-grid';
function decodeParams(url) {
  const params = new URL(url).searchParams;
  const decodedParams = {};
  const array = Array.from(params.entries());
  for (const [key, value] of array) {
    try {
      decodedParams[key] = JSON.parse(decodeURIComponent(value));
    } catch (e) {
      decodedParams[key] = value;
    }
  }
  return decodedParams;
}
const getInitialState = (columns, groupingField) => {
  const columnVisibilityModel = {};
  columns.forEach(col => {
    if (col.hide) {
      columnVisibilityModel[col.field] = false;
    }
  });
  if (groupingField) {
    columnVisibilityModel[groupingField] = false;
  }
  return {
    columns: {
      columnVisibilityModel
    }
  };
};
const defaultColDef = (0, _xDataGridPro.getGridDefaultColumnTypes)();
const useMockServer = (dataSetOptions, serverOptions, shouldRequestsFail) => {
  const [data, setData] = React.useState();
  const [index, setIndex] = React.useState(0);
  const shouldRequestsFailRef = React.useRef(shouldRequestsFail ?? false);
  React.useEffect(() => {
    if (shouldRequestsFail !== undefined) {
      shouldRequestsFailRef.current = shouldRequestsFail;
    }
  }, [shouldRequestsFail]);
  const options = (0, _extends2.default)({}, _serverUtils.DEFAULT_DATASET_OPTIONS, dataSetOptions);
  const columns = React.useMemo(() => {
    return (0, _useDemoData.getColumnsFromOptions)({
      dataSet: options.dataSet,
      editable: options.editable,
      maxColumns: options.maxColumns,
      visibleFields: options.visibleFields
    });
  }, [options.dataSet, options.editable, options.maxColumns, options.visibleFields]);
  const initialState = React.useMemo(() => getInitialState(columns, options.treeData?.groupingField), [columns, options.treeData?.groupingField]);
  const columnsWithDefaultColDef = React.useMemo(() => columns.map(column => (0, _extends2.default)({}, defaultColDef[column.type || 'string'], column)), [columns]);
  const isTreeData = options.treeData?.groupingField != null;
  const getGroupKey = React.useMemo(() => {
    if (isTreeData) {
      return row => row[options.treeData.groupingField];
    }
    return undefined;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [options.treeData?.groupingField, isTreeData]);
  const getChildrenCount = React.useMemo(() => {
    if (isTreeData) {
      return row => row.descendantCount;
    }
    return undefined;
  }, [isTreeData]);
  React.useEffect(() => {
    const cacheKey = `${options.dataSet}-${options.rowLength}-${index}-${options.maxColumns}`;

    // Cache to allow fast switch between the JavaScript and TypeScript version
    // of the demos.
    if (dataCache.has(cacheKey)) {
      const newData = dataCache.get(cacheKey);
      setData(newData);
      return undefined;
    }
    let active = true;
    (async () => {
      let rowData;
      const rowLength = options.rowLength;
      if (rowLength > 1000) {
        rowData = await (0, _realDataService.getRealGridData)(1000, columns);
        rowData = await (0, _useDemoData.extrapolateSeed)(rowLength, rowData);
      } else {
        rowData = await (0, _realDataService.getRealGridData)(rowLength, columns);
      }
      if (!active) {
        return;
      }
      if (isTreeData) {
        rowData = (0, _treeDataGenerator.addTreeDataOptionsToDemoData)(rowData, {
          maxDepth: options.treeData?.maxDepth,
          groupingField: options.treeData?.groupingField,
          averageChildren: options.treeData?.averageChildren
        });
      }
      if (process.env.NODE_ENV !== 'production') {
        (0, _useDemoData.deepFreeze)(rowData);
      }
      dataCache.set(cacheKey, rowData);
      setData(rowData);
    })();
    return () => {
      active = false;
    };
  }, [columns, isTreeData, options.rowLength, options.treeData?.maxDepth, options.treeData?.groupingField, options.treeData?.averageChildren, options.dataSet, options.maxColumns, index]);
  const fetchRows = React.useCallback(async requestUrl => {
    if (!data || !requestUrl) {
      return new Promise(resolve => {
        resolve({
          rows: [],
          rowCount: 0
        });
      });
    }
    const params = decodeParams(requestUrl);
    const verbose = serverOptions?.verbose ?? true;
    // eslint-disable-next-line no-console
    const print = console.info;
    if (verbose) {
      print('MUI X: DATASOURCE REQUEST', params);
    }
    let getRowsResponse;
    const serverOptionsWithDefault = {
      minDelay: serverOptions?.minDelay ?? _serverUtils.DEFAULT_SERVER_OPTIONS.minDelay,
      maxDelay: serverOptions?.maxDelay ?? _serverUtils.DEFAULT_SERVER_OPTIONS.maxDelay,
      useCursorPagination: serverOptions?.useCursorPagination ?? _serverUtils.DEFAULT_SERVER_OPTIONS.useCursorPagination
    };
    if (shouldRequestsFailRef.current) {
      const {
        minDelay,
        maxDelay
      } = serverOptionsWithDefault;
      const delay = (0, _services.randomInt)(minDelay, maxDelay);
      return new Promise((_, reject) => {
        if (verbose) {
          print('MUI X: DATASOURCE REQUEST FAILURE', params);
        }
        setTimeout(() => reject(new Error('Could not fetch the data')), delay);
      });
    }
    if (isTreeData /* || TODO: `isRowGrouping` */) {
      const {
        rows,
        rootRowCount
      } = await (0, _serverUtils.processTreeDataRows)(data.rows, params, serverOptionsWithDefault, columnsWithDefaultColDef);
      getRowsResponse = {
        rows: rows.slice().map(row => (0, _extends2.default)({}, row, {
          path: undefined
        })),
        rowCount: rootRowCount
      };
    } else {
      // plain data
      const {
        returnedRows,
        nextCursor,
        totalRowCount
      } = await (0, _serverUtils.loadServerRows)(data.rows, (0, _extends2.default)({}, params, params.paginationModel), serverOptionsWithDefault, columnsWithDefaultColDef);
      getRowsResponse = {
        rows: returnedRows,
        rowCount: totalRowCount,
        pageInfo: {
          nextCursor
        }
      };
    }
    return new Promise(resolve => {
      if (verbose) {
        print('MUI X: DATASOURCE RESPONSE', params, getRowsResponse);
      }
      resolve(getRowsResponse);
    });
  }, [data, serverOptions?.verbose, serverOptions?.minDelay, serverOptions?.maxDelay, serverOptions?.useCursorPagination, isTreeData, columnsWithDefaultColDef]);
  return {
    columns: columnsWithDefaultColDef,
    initialState,
    getGroupKey,
    getChildrenCount,
    fetchRows,
    loadNewData: () => {
      setIndex(oldIndex => oldIndex + 1);
    }
  };
};
exports.useMockServer = useMockServer;